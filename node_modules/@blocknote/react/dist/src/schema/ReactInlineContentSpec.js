import { jsx as _jsx } from "react/jsx-runtime";
import { addInlineContentAttributes, addInlineContentKeyboardShortcuts, camelToDataKebab, createInternalInlineContentSpec, createStronglyTypedTiptapNode, getInlineContentParseRules, inlineContentToNodes, nodeToCustomInlineContent, propsToAttributes, } from "@blocknote/core";
import { NodeViewContent, NodeViewWrapper, ReactNodeViewRenderer, } from "@tiptap/react";
import { renderToDOMSpec } from "./@util/ReactRenderUtil.js";
// Function that adds a wrapper with necessary classes and attributes to the
// component returned from a custom inline content's 'render' function, to
// ensure no data is lost on internal copy & paste.
export function InlineContentWrapper(props) {
    return (
    // Creates inline content section element
    _jsx(NodeViewWrapper, { as: "span", 
        // Sets inline content section class
        className: "bn-inline-content-section", "data-inline-content-type": props.inlineContentType, ...Object.fromEntries(Object.entries(props.inlineContentProps)
            .filter(([prop, value]) => value !== props.propSchema[prop].default)
            .map(([prop, value]) => {
            return [camelToDataKebab(prop), value];
        })), children: props.children }));
}
// A function to create custom block for API consumers
// we want to hide the tiptap node from API consumers and provide a simpler API surface instead
export function createReactInlineContentSpec(inlineContentConfig, inlineContentImplementation) {
    const node = createStronglyTypedTiptapNode({
        name: inlineContentConfig.type,
        inline: true,
        group: "inline",
        selectable: inlineContentConfig.content === "styled",
        atom: inlineContentConfig.content === "none",
        content: (inlineContentConfig.content === "styled"
            ? "inline*"
            : ""),
        addAttributes() {
            return propsToAttributes(inlineContentConfig.propSchema);
        },
        addKeyboardShortcuts() {
            return addInlineContentKeyboardShortcuts(inlineContentConfig);
        },
        parseHTML() {
            return getInlineContentParseRules(inlineContentConfig);
        },
        renderHTML({ node }) {
            const editor = this.options.editor;
            const ic = nodeToCustomInlineContent(node, editor.schema.inlineContentSchema, editor.schema.styleSchema); // TODO: fix cast
            const Content = inlineContentImplementation.render;
            const output = renderToDOMSpec((refCB) => (_jsx(Content, { inlineContent: ic, updateInlineContent: () => {
                    // No-op
                }, contentRef: refCB })), editor);
            return addInlineContentAttributes(output, inlineContentConfig.type, node.attrs, inlineContentConfig.propSchema);
        },
        // TODO: needed?
        addNodeView() {
            const editor = this.options.editor;
            return (props) => ReactNodeViewRenderer((props) => {
                // hacky, should export `useReactNodeView` from tiptap to get access to ref
                const ref = NodeViewContent({}).ref;
                const Content = inlineContentImplementation.render;
                return (_jsx(InlineContentWrapper, { inlineContentProps: props.node.attrs, inlineContentType: inlineContentConfig.type, propSchema: inlineContentConfig.propSchema, children: _jsx(Content, { contentRef: ref, inlineContent: nodeToCustomInlineContent(props.node, editor.schema.inlineContentSchema, editor.schema.styleSchema) // TODO: fix cast
                        , updateInlineContent: (update) => {
                            const content = inlineContentToNodes([update], editor._tiptapEditor.schema, editor.schema.styleSchema);
                            editor._tiptapEditor.view.dispatch(editor._tiptapEditor.view.state.tr.replaceWith(props.getPos(), props.getPos() + props.node.nodeSize, content));
                        } }) }));
            }, {
                className: "bn-ic-react-node-view-renderer",
                as: "span",
                // contentDOMElementTag: "span", (requires tt upgrade)
            })(props);
        },
    });
    return createInternalInlineContentSpec(inlineContentConfig, {
        node: node,
    });
}
//# sourceMappingURL=ReactInlineContentSpec.js.map