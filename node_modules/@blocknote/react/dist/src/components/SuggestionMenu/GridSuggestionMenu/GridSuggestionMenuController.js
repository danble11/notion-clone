import { jsx as _jsx } from "react/jsx-runtime";
import { flip, offset, size } from "@floating-ui/react";
import { useCallback, useMemo } from "react";
import { useBlockNoteEditor } from "../../../hooks/useBlockNoteEditor.js";
import { useUIElementPositioning } from "../../../hooks/useUIElementPositioning.js";
import { useUIPluginState } from "../../../hooks/useUIPluginState.js";
import { getDefaultReactEmojiPickerItems } from "./getDefaultReactEmojiPickerItems.js";
import { GridSuggestionMenu } from "./GridSuggestionMenu.js";
import { GridSuggestionMenuWrapper } from "./GridSuggestionMenuWrapper.js";
export function GridSuggestionMenuController(props) {
    const editor = useBlockNoteEditor();
    const { triggerCharacter, gridSuggestionMenuComponent, columns, minQueryLength, onItemClick, getItems, floatingOptions, } = props;
    const onItemClickOrDefault = useMemo(() => {
        return (onItemClick ||
            ((item) => {
                item.onItemClick(editor);
            }));
    }, [editor, onItemClick]);
    const getItemsOrDefault = useMemo(() => {
        return (getItems ||
            (async (query) => await getDefaultReactEmojiPickerItems(editor, query)));
    }, [editor, getItems]);
    const callbacks = {
        closeMenu: editor.suggestionMenus.closeMenu,
        clearQuery: editor.suggestionMenus.clearQuery,
    };
    const cb = useCallback((callback) => {
        return editor.suggestionMenus.onUpdate(triggerCharacter, callback);
    }, [editor.suggestionMenus, triggerCharacter]);
    const state = useUIPluginState(cb);
    const { isMounted, ref, style, getFloatingProps } = useUIElementPositioning(state?.show || false, state?.referencePos || null, 2000, {
        placement: "bottom-start",
        middleware: [
            offset(10),
            // Flips the menu placement to maximize the space available, and prevents
            // the menu from being cut off by the confines of the screen.
            flip(),
            size({
                apply({ availableHeight, elements }) {
                    Object.assign(elements.floating.style, {
                        maxHeight: `${availableHeight - 10}px`,
                    });
                },
            }),
        ],
        onOpenChange(open) {
            if (!open) {
                editor.suggestionMenus.closeMenu();
            }
        },
        ...floatingOptions,
    });
    if (!isMounted ||
        !state ||
        (!state?.ignoreQueryLength &&
            minQueryLength &&
            (state.query.startsWith(" ") || state.query.length < minQueryLength))) {
        return null;
    }
    return (_jsx("div", { ref: ref, style: style, ...getFloatingProps(), children: _jsx(GridSuggestionMenuWrapper, { query: state.query, closeMenu: callbacks.closeMenu, clearQuery: callbacks.clearQuery, getItems: getItemsOrDefault, columns: columns, gridSuggestionMenuComponent: gridSuggestionMenuComponent || GridSuggestionMenu, onItemClick: onItemClickOrDefault }) }));
}
//# sourceMappingURL=GridSuggestionMenuController.js.map