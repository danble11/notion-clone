import { jsx as _jsx } from "react/jsx-runtime";
import { flip, offset } from "@floating-ui/react";
import { useMemo, useRef, useState } from "react";
import { useBlockNoteEditor } from "../../hooks/useBlockNoteEditor.js";
import { useEditorContentOrSelectionChange } from "../../hooks/useEditorContentOrSelectionChange.js";
import { useUIElementPositioning } from "../../hooks/useUIElementPositioning.js";
import { useUIPluginState } from "../../hooks/useUIPluginState.js";
import { mergeRefs } from "../../util/mergeRefs.js";
import { FormattingToolbar } from "./FormattingToolbar.js";
const textAlignmentToPlacement = (textAlignment) => {
    switch (textAlignment) {
        case "left":
            return "top-start";
        case "center":
            return "top";
        case "right":
            return "top-end";
        default:
            return "top-start";
    }
};
export const FormattingToolbarController = (props) => {
    const divRef = useRef(null);
    const editor = useBlockNoteEditor();
    const [placement, setPlacement] = useState(() => {
        const block = editor.getTextCursorPosition().block;
        if (!("textAlignment" in block.props)) {
            return "top-start";
        }
        return textAlignmentToPlacement(block.props.textAlignment);
    });
    useEditorContentOrSelectionChange(() => {
        const block = editor.getTextCursorPosition().block;
        if (!("textAlignment" in block.props)) {
            setPlacement("top-start");
        }
        else {
            setPlacement(textAlignmentToPlacement(block.props.textAlignment));
        }
    }, editor);
    const state = useUIPluginState(editor.formattingToolbar.onUpdate.bind(editor.formattingToolbar));
    const { isMounted, ref, style, getFloatingProps } = useUIElementPositioning(state?.show || false, state?.referencePos || null, 3000, {
        placement,
        middleware: [offset(10), flip()],
        onOpenChange: (open, _event) => {
            // console.log("change", event);
            if (!open) {
                editor.formattingToolbar.closeMenu();
                editor.focus();
            }
        },
        ...props.floatingOptions,
    });
    const combinedRef = useMemo(() => mergeRefs([divRef, ref]), [divRef, ref]);
    if (!isMounted || !state) {
        return null;
    }
    if (!state.show && divRef.current) {
        // The component is fading out. Use the previous state to render the toolbar with innerHTML,
        // because otherwise the toolbar will quickly flickr (i.e.: show a different state) while fading out,
        // which looks weird
        return (_jsx("div", { ref: combinedRef, style: style, dangerouslySetInnerHTML: { __html: divRef.current.innerHTML } }));
    }
    const Component = props.formattingToolbar || FormattingToolbar;
    return (_jsx("div", { ref: combinedRef, style: style, ...getFloatingProps(), children: _jsx(Component, {}) }));
};
//# sourceMappingURL=FormattingToolbarController.js.map