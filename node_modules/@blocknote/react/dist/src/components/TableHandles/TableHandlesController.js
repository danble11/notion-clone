import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useCallback, useMemo, useState } from "react";
import { FloatingPortal } from "@floating-ui/react";
import { useBlockNoteEditor } from "../../hooks/useBlockNoteEditor.js";
import { useUIPluginState } from "../../hooks/useUIPluginState.js";
import { ExtendButton } from "./ExtendButton/ExtendButton.js";
import { TableHandle } from "./TableHandle.js";
import { useExtendButtonsPositioning } from "./hooks/useExtendButtonsPositioning.js";
import { useTableHandlesPositioning } from "./hooks/useTableHandlesPositioning.js";
export const TableHandlesController = (props) => {
    const editor = useBlockNoteEditor();
    const [menuContainerRef, setMenuContainerRef] = useState(null);
    if (!editor.tableHandles) {
        throw new Error("TableHandlesController can only be used when BlockNote editor schema contains table block");
    }
    const callbacks = {
        rowDragStart: editor.tableHandles.rowDragStart,
        colDragStart: editor.tableHandles.colDragStart,
        dragEnd: editor.tableHandles.dragEnd,
        freezeHandles: editor.tableHandles.freezeHandles,
        unfreezeHandles: editor.tableHandles.unfreezeHandles,
    };
    const { freezeHandles, unfreezeHandles } = callbacks;
    const onStartExtend = useCallback(() => {
        freezeHandles();
        setHideCol(true);
        setHideRow(true);
    }, [freezeHandles]);
    const onEndExtend = useCallback(() => {
        unfreezeHandles();
        setHideCol(false);
        setHideRow(false);
    }, [unfreezeHandles]);
    const state = useUIPluginState(editor.tableHandles.onUpdate.bind(editor.tableHandles));
    const draggingState = useMemo(() => {
        return state?.draggingState
            ? {
                draggedCellOrientation: state?.draggingState?.draggedCellOrientation,
                mousePos: state?.draggingState?.mousePos,
            }
            : undefined;
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        state?.draggingState,
        state?.draggingState?.draggedCellOrientation,
        state?.draggingState?.mousePos,
    ]);
    const { rowHandle, colHandle } = useTableHandlesPositioning(state?.show || false, state?.referencePosCell || null, state?.referencePosTable || null, draggingState);
    const { addOrRemoveColumnsButton, addOrRemoveRowsButton } = useExtendButtonsPositioning(state?.showAddOrRemoveColumnsButton || false, state?.showAddOrRemoveRowsButton || false, state?.referencePosTable || null);
    const [hideRow, setHideRow] = useState(false);
    const [hideCol, setHideCol] = useState(false);
    if (!state) {
        return null;
    }
    const TableHandleComponent = props.tableHandle || TableHandle;
    const ExtendButtonComponent = props.extendButton || ExtendButton;
    return (_jsxs(_Fragment, { children: [_jsx("div", { ref: setMenuContainerRef }), _jsxs(FloatingPortal, { root: state.widgetContainer, children: [!hideRow &&
                        menuContainerRef &&
                        rowHandle.isMounted &&
                        state.rowIndex !== undefined && (_jsx("div", { ref: rowHandle.ref, style: rowHandle.style, children: _jsx(TableHandleComponent
                        // This "as any" unfortunately seems complicated to fix
                        , { 
                            // This "as any" unfortunately seems complicated to fix
                            editor: editor, orientation: "row", showOtherSide: () => setHideCol(false), hideOtherSide: () => setHideCol(true), index: state.rowIndex, block: state.block, dragStart: callbacks.rowDragStart, dragEnd: callbacks.dragEnd, freezeHandles: callbacks.freezeHandles, unfreezeHandles: callbacks.unfreezeHandles, menuContainer: menuContainerRef }) })), !hideCol &&
                        menuContainerRef &&
                        colHandle.isMounted &&
                        state.colIndex !== undefined && (_jsx("div", { ref: colHandle.ref, style: colHandle.style, children: _jsx(TableHandleComponent, { editor: editor, orientation: "column", showOtherSide: () => setHideRow(false), hideOtherSide: () => setHideRow(true), index: state.colIndex, block: state.block, dragStart: callbacks.colDragStart, dragEnd: callbacks.dragEnd, freezeHandles: callbacks.freezeHandles, unfreezeHandles: callbacks.unfreezeHandles, menuContainer: menuContainerRef }) })), _jsx("div", { ref: addOrRemoveRowsButton.ref, style: addOrRemoveRowsButton.style, children: _jsx(ExtendButtonComponent, { editor: editor, orientation: "addOrRemoveRows", block: state.block, onMouseDown: onStartExtend, onMouseUp: onEndExtend }) }), _jsx("div", { ref: addOrRemoveColumnsButton.ref, style: addOrRemoveColumnsButton.style, children: _jsx(ExtendButtonComponent, { editor: editor, orientation: "addOrRemoveColumns", block: state.block, onMouseDown: onStartExtend, onMouseUp: onEndExtend }) })] })] }));
};
//# sourceMappingURL=TableHandlesController.js.map