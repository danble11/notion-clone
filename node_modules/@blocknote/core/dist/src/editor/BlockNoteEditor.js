import { Extension, getSchema, Mark, Node as TipTapNode, } from "@tiptap/core";
import { insertBlocks } from "../api/blockManipulation/commands/insertBlocks/insertBlocks.js";
import { moveBlockDown, moveBlockUp, } from "../api/blockManipulation/commands/moveBlock/moveBlock.js";
import { canNestBlock, canUnnestBlock, nestBlock, unnestBlock, } from "../api/blockManipulation/commands/nestBlock/nestBlock.js";
import { removeBlocks } from "../api/blockManipulation/commands/removeBlocks/removeBlocks.js";
import { replaceBlocks } from "../api/blockManipulation/commands/replaceBlocks/replaceBlocks.js";
import { updateBlock } from "../api/blockManipulation/commands/updateBlock/updateBlock.js";
import { insertContentAt } from "../api/blockManipulation/insertContentAt.js";
import { getTextCursorPosition, setTextCursorPosition, } from "../api/blockManipulation/selections/textCursorPosition/textCursorPosition.js";
import { createExternalHTMLExporter } from "../api/exporters/html/externalHTMLExporter.js";
import { blocksToMarkdown } from "../api/exporters/markdown/markdownExporter.js";
import { HTMLToBlocks } from "../api/parsers/html/parseHTML.js";
import { markdownToBlocks } from "../api/parsers/markdown/parseMarkdown.js";
import { UniqueID } from "../extensions/UniqueID/UniqueID.js";
import { mergeCSSClasses } from "../util/browser.js";
import { UnreachableCaseError } from "../util/typescript.js";
import { getBlockNoteExtensions } from "./BlockNoteExtensions.js";
import { transformPasted } from "./transformPasted.js";
import { checkDefaultBlockTypeInSchema } from "../blocks/defaultBlockTypeGuards.js";
import { BlockNoteSchema } from "./BlockNoteSchema.js";
import { BlockNoteTipTapEditor, } from "./BlockNoteTipTapEditor.js";
import { en } from "../i18n/locales/index.js";
import { dropCursor } from "prosemirror-dropcursor";
import { createInternalHTMLSerializer } from "../api/exporters/html/internalHTMLSerializer.js";
import { inlineContentToNodes } from "../api/nodeConversions/blockToNode.js";
import { nodeToBlock } from "../api/nodeConversions/nodeToBlock.js";
import "../style.css";
const blockNoteTipTapOptions = {
    enableInputRules: true,
    enablePasteRules: true,
    enableCoreExtensions: false,
};
export class BlockNoteEditor {
    options;
    _pmSchema;
    /**
     * extensions that are added to the editor, can be tiptap extensions or prosemirror plugins
     */
    extensions = {};
    /**
     * Boolean indicating whether the editor is in headless mode.
     * Headless mode means we can use features like importing / exporting blocks,
     * but there's no underlying editor (UI) instantiated.
     *
     * You probably don't need to set this manually, but use the `server-util` package instead that uses this option internally
     */
    headless = false;
    _tiptapEditor = undefined; // TODO: Type should actually reflect that it can be `undefined` in headless mode
    /**
     * Used by React to store a reference to an `ElementRenderer` helper utility to make sure we can render React elements
     * in the correct context (used by `ReactRenderUtil`)
     */
    elementRenderer = null;
    /**
     * Cache of all blocks. This makes sure we don't have to "recompute" blocks if underlying Prosemirror Nodes haven't changed.
     * This is especially useful when we want to keep track of the same block across multiple operations,
     * with this cache, blocks stay the same object reference (referential equality with ===).
     */
    blockCache = new WeakMap();
    /**
     * The dictionary contains translations for the editor.
     */
    dictionary;
    /**
     * The schema of the editor. The schema defines which Blocks, InlineContent, and Styles are available in the editor.
     */
    schema;
    blockImplementations;
    inlineContentImplementations;
    styleImplementations;
    formattingToolbar;
    linkToolbar;
    sideMenu;
    suggestionMenus;
    filePanel;
    tableHandles;
    /**
     * The `uploadFile` method is what the editor uses when files need to be uploaded (for example when selecting an image to upload).
     * This method should set when creating the editor as this is application-specific.
     *
     * `undefined` means the application doesn't support file uploads.
     *
     * @param file The file that should be uploaded.
     * @returns The URL of the uploaded file OR an object containing props that should be set on the file block (such as an id)
     */
    uploadFile;
    onUploadStartCallbacks = [];
    onUploadEndCallbacks = [];
    resolveFileUrl;
    get pmSchema() {
        return this._pmSchema;
    }
    static create(options = {}) {
        return new BlockNoteEditor(options);
    }
    constructor(options) {
        this.options = options;
        const anyOpts = options;
        if (anyOpts.onEditorContentChange) {
            throw new Error("onEditorContentChange initialization option is deprecated, use <BlockNoteView onChange={...} />, the useEditorChange(...) hook, or editor.onChange(...)");
        }
        if (anyOpts.onTextCursorPositionChange) {
            throw new Error("onTextCursorPositionChange initialization option is deprecated, use <BlockNoteView onSelectionChange={...} />, the useEditorSelectionChange(...) hook, or editor.onSelectionChange(...)");
        }
        if (anyOpts.onEditorReady) {
            throw new Error("onEditorReady is deprecated. Editor is immediately ready for use after creation.");
        }
        if (anyOpts.editable) {
            throw new Error("editable initialization option is deprecated, use <BlockNoteView editable={true/false} />, or alternatively editor.isEditable = true/false");
        }
        this.dictionary = options.dictionary || en;
        // apply defaults
        const newOptions = {
            defaultStyles: true,
            schema: options.schema || BlockNoteSchema.create(),
            _headless: false,
            ...options,
            placeholders: {
                ...this.dictionary.placeholders,
                ...options.placeholders,
            },
        };
        // @ts-ignore
        this.schema = newOptions.schema;
        this.blockImplementations = newOptions.schema.blockSpecs;
        this.inlineContentImplementations = newOptions.schema.inlineContentSpecs;
        this.styleImplementations = newOptions.schema.styleSpecs;
        this.extensions = getBlockNoteExtensions({
            editor: this,
            domAttributes: newOptions.domAttributes || {},
            blockSpecs: this.schema.blockSpecs,
            styleSpecs: this.schema.styleSpecs,
            inlineContentSpecs: this.schema.inlineContentSpecs,
            collaboration: newOptions.collaboration,
            trailingBlock: newOptions.trailingBlock,
            disableExtensions: newOptions.disableExtensions,
            setIdAttribute: newOptions.setIdAttribute,
            animations: newOptions.animations ?? true,
            tableHandles: checkDefaultBlockTypeInSchema("table", this),
            dropCursor: this.options.dropCursor ?? dropCursor,
            placeholders: newOptions.placeholders,
        });
        // add extensions from _tiptapOptions
        (newOptions._tiptapOptions?.extensions || []).forEach((ext) => {
            this.extensions[ext.name] = ext;
        });
        // add extensions from options
        Object.entries(newOptions._extensions || {}).forEach(([key, ext]) => {
            this.extensions[key] = ext;
        });
        this.formattingToolbar = this.extensions["formattingToolbar"];
        this.linkToolbar = this.extensions["linkToolbar"];
        this.sideMenu = this.extensions["sideMenu"];
        this.suggestionMenus = this.extensions["suggestionMenus"];
        this.filePanel = this.extensions["filePanel"];
        this.tableHandles = this.extensions["tableHandles"];
        if (newOptions.uploadFile) {
            const uploadFile = newOptions.uploadFile;
            this.uploadFile = async (file, block) => {
                this.onUploadStartCallbacks.forEach((callback) => callback.apply(this, [block]));
                try {
                    return await uploadFile(file, block);
                }
                finally {
                    this.onUploadEndCallbacks.forEach((callback) => callback.apply(this, [block]));
                }
            };
        }
        this.resolveFileUrl = newOptions.resolveFileUrl || (async (url) => url);
        this.headless = newOptions._headless;
        if (newOptions.collaboration && newOptions.initialContent) {
            // eslint-disable-next-line no-console
            console.warn("When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider");
        }
        const initialContent = newOptions.initialContent ||
            (options.collaboration
                ? [
                    {
                        type: "paragraph",
                        id: "initialBlockId",
                    },
                ]
                : [
                    {
                        type: "paragraph",
                        id: UniqueID.options.generateID(),
                    },
                ]);
        if (!Array.isArray(initialContent) || initialContent.length === 0) {
            throw new Error("initialContent must be a non-empty array of blocks, received: " +
                initialContent);
        }
        const tiptapExtensions = [
            ...Object.entries(this.extensions).map(([key, ext]) => {
                if (ext instanceof Extension ||
                    ext instanceof TipTapNode ||
                    ext instanceof Mark) {
                    // tiptap extension
                    return ext;
                }
                if (!ext.plugin) {
                    throw new Error("Extension should either be a TipTap extension or a ProseMirror plugin in a plugin property");
                }
                // "blocknote" extensions (prosemirror plugins)
                return Extension.create({
                    name: key,
                    addProseMirrorPlugins: () => [ext.plugin],
                });
            }),
        ];
        const tiptapOptions = {
            ...blockNoteTipTapOptions,
            ...newOptions._tiptapOptions,
            content: initialContent,
            extensions: tiptapExtensions,
            editorProps: {
                ...newOptions._tiptapOptions?.editorProps,
                attributes: {
                    // As of TipTap v2.5.0 the tabIndex is removed when the editor is not
                    // editable, so you can't focus it. We want to revert this as we have
                    // UI behaviour that relies on it.
                    tabIndex: "0",
                    ...newOptions._tiptapOptions?.editorProps?.attributes,
                    ...newOptions.domAttributes?.editor,
                    class: mergeCSSClasses("bn-editor", newOptions.defaultStyles ? "bn-default-styles" : "", newOptions.domAttributes?.editor?.class || ""),
                },
                transformPasted,
            },
        };
        if (!this.headless) {
            this._tiptapEditor = BlockNoteTipTapEditor.create(tiptapOptions, this.schema.styleSchema);
            this._pmSchema = this._tiptapEditor.schema;
        }
        else {
            // In headless mode, we don't instantiate an underlying TipTap editor,
            // but we still need the schema
            this._pmSchema = getSchema(tiptapOptions.extensions);
        }
    }
    dispatch(tr) {
        this._tiptapEditor.dispatch(tr);
    }
    /**
     * Mount the editor to a parent DOM element. Call mount(undefined) to clean up
     *
     * @warning Not needed to call manually when using React, use BlockNoteView to take care of mounting
     */
    mount = (parentElement) => {
        this._tiptapEditor.mount(parentElement);
    };
    get prosemirrorView() {
        return this._tiptapEditor.view;
    }
    get domElement() {
        return this._tiptapEditor.view.dom;
    }
    isFocused() {
        return this._tiptapEditor.view.hasFocus();
    }
    focus() {
        this._tiptapEditor.view.focus();
    }
    onUploadStart(callback) {
        this.onUploadStartCallbacks.push(callback);
        return () => {
            const index = this.onUploadStartCallbacks.indexOf(callback);
            if (index > -1) {
                this.onUploadStartCallbacks.splice(index, 1);
            }
        };
    }
    onUploadEnd(callback) {
        this.onUploadEndCallbacks.push(callback);
        return () => {
            const index = this.onUploadEndCallbacks.indexOf(callback);
            if (index > -1) {
                this.onUploadEndCallbacks.splice(index, 1);
            }
        };
    }
    /**
     * @deprecated, use `editor.document` instead
     */
    get topLevelBlocks() {
        return this.document;
    }
    /**
     * Gets a snapshot of all top-level (non-nested) blocks in the editor.
     * @returns A snapshot of all top-level (non-nested) blocks in the editor.
     */
    get document() {
        const blocks = [];
        this._tiptapEditor.state.doc.firstChild.descendants((node) => {
            blocks.push(nodeToBlock(node, this.schema.blockSchema, this.schema.inlineContentSchema, this.schema.styleSchema, this.blockCache));
            return false;
        });
        return blocks;
    }
    /**
     * Gets a snapshot of an existing block from the editor.
     * @param blockIdentifier The identifier of an existing block that should be retrieved.
     * @returns The block that matches the identifier, or `undefined` if no matching block was found.
     */
    getBlock(blockIdentifier) {
        const id = typeof blockIdentifier === "string"
            ? blockIdentifier
            : blockIdentifier.id;
        let newBlock = undefined;
        this._tiptapEditor.state.doc.firstChild.descendants((node) => {
            if (typeof newBlock !== "undefined") {
                return false;
            }
            if (node.type.name !== "blockContainer" || node.attrs.id !== id) {
                return true;
            }
            newBlock = nodeToBlock(node, this.schema.blockSchema, this.schema.inlineContentSchema, this.schema.styleSchema, this.blockCache);
            return false;
        });
        return newBlock;
    }
    /**
     * Traverses all blocks in the editor depth-first, and executes a callback for each.
     * @param callback The callback to execute for each block. Returning `false` stops the traversal.
     * @param reverse Whether the blocks should be traversed in reverse order.
     */
    forEachBlock(callback, reverse = false) {
        const blocks = this.document.slice();
        if (reverse) {
            blocks.reverse();
        }
        function traverseBlockArray(blockArray) {
            for (const block of blockArray) {
                if (callback(block) === false) {
                    return false;
                }
                const children = reverse
                    ? block.children.slice().reverse()
                    : block.children;
                if (!traverseBlockArray(children)) {
                    return false;
                }
            }
            return true;
        }
        traverseBlockArray(blocks);
    }
    /**
     * Executes a callback whenever the editor's contents change.
     * @param callback The callback to execute.
     */
    onEditorContentChange(callback) {
        this._tiptapEditor.on("update", callback);
    }
    /**
     * Executes a callback whenever the editor's selection changes.
     * @param callback The callback to execute.
     */
    onEditorSelectionChange(callback) {
        this._tiptapEditor.on("selectionUpdate", callback);
    }
    /**
     * Gets a snapshot of the current text cursor position.
     * @returns A snapshot of the current text cursor position.
     */
    getTextCursorPosition() {
        return getTextCursorPosition(this);
    }
    /**
     * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could
     * not be found.
     * @param targetBlock The identifier of an existing block that the text cursor should be moved to.
     * @param placement Whether the text cursor should be placed at the start or end of the block.
     */
    setTextCursorPosition(targetBlock, placement = "start") {
        setTextCursorPosition(this, targetBlock, placement);
    }
    /**
     * Gets a snapshot of the current selection.
     */
    getSelection() {
        // Either the TipTap selection is empty, or it's a node selection. In either
        // case, it only spans one block, so we return undefined.
        if (this._tiptapEditor.state.selection.from ===
            this._tiptapEditor.state.selection.to ||
            "node" in this._tiptapEditor.state.selection) {
            return undefined;
        }
        const blocks = [];
        // TODO: This adds all child blocks to the same array. Needs to find min
        //  depth and only add blocks at that depth.
        this._tiptapEditor.state.doc.descendants((node, pos) => {
            if (node.type.spec.group !== "blockContent") {
                return true;
            }
            // Fixed the block pos and size
            // all block is wrapped with a blockContent wrapper
            // and blockContent wrapper pos = inner block pos - 1
            // blockContent wrapper end = inner block pos + nodeSize + 1
            // need to add 1 to start and -1 to end
            const end = pos + node.nodeSize - 1;
            const start = pos + 1;
            if (end <= this._tiptapEditor.state.selection.from ||
                start >= this._tiptapEditor.state.selection.to) {
                return true;
            }
            blocks.push(nodeToBlock(this._tiptapEditor.state.doc.resolve(pos).node(), this.schema.blockSchema, this.schema.inlineContentSchema, this.schema.styleSchema, this.blockCache));
            return false;
        });
        return { blocks: blocks };
    }
    /**
     * Checks if the editor is currently editable, or if it's locked.
     * @returns True if the editor is editable, false otherwise.
     */
    get isEditable() {
        if (!this._tiptapEditor) {
            if (!this.headless) {
                throw new Error("no editor, but also not headless?");
            }
            return false;
        }
        return this._tiptapEditor.isEditable === undefined
            ? true
            : this._tiptapEditor.isEditable;
    }
    /**
     * Makes the editor editable or locks it, depending on the argument passed.
     * @param editable True to make the editor editable, or false to lock it.
     */
    set isEditable(editable) {
        if (!this._tiptapEditor) {
            if (!this.headless) {
                throw new Error("no editor, but also not headless?");
            }
            // not relevant on headless
            return;
        }
        if (this._tiptapEditor.options.editable !== editable) {
            this._tiptapEditor.setEditable(editable);
        }
    }
    /**
     * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an
     * error if the reference block could not be found.
     * @param blocksToInsert An array of partial blocks that should be inserted.
     * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.
     * @param placement Whether the blocks should be inserted just before, just after, or nested inside the
     * `referenceBlock`.
     */
    insertBlocks(blocksToInsert, referenceBlock, placement = "before") {
        return insertBlocks(this, blocksToInsert, referenceBlock, placement);
    }
    /**
     * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be
     * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could
     * not be found.
     * @param blockToUpdate The block that should be updated.
     * @param update A partial block which defines how the existing block should be changed.
     */
    updateBlock(blockToUpdate, update) {
        return updateBlock(this, blockToUpdate, update);
    }
    /**
     * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.
     * @param blocksToRemove An array of identifiers for existing blocks that should be removed.
     */
    removeBlocks(blocksToRemove) {
        return removeBlocks(this, blocksToRemove);
    }
    /**
     * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or
     * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in
     * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.
     * @param blocksToRemove An array of blocks that should be replaced.
     * @param blocksToInsert An array of partial blocks to replace the old ones with.
     */
    replaceBlocks(blocksToRemove, blocksToInsert) {
        return replaceBlocks(this, blocksToRemove, blocksToInsert);
    }
    /**
     * Insert a piece of content at the current cursor position.
     *
     * @param content can be a string, or array of partial inline content elements
     */
    insertInlineContent(content) {
        const nodes = inlineContentToNodes(content, this.pmSchema, this.schema.styleSchema);
        insertContentAt({
            from: this._tiptapEditor.state.selection.from,
            to: this._tiptapEditor.state.selection.to,
        }, nodes, this);
    }
    /**
     * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.
     */
    getActiveStyles() {
        const styles = {};
        const marks = this._tiptapEditor.state.selection.$to.marks();
        for (const mark of marks) {
            const config = this.schema.styleSchema[mark.type.name];
            if (!config) {
                if (mark.type.name !== "link") {
                    // eslint-disable-next-line no-console
                    console.warn("mark not found in styleschema", mark.type.name);
                }
                continue;
            }
            if (config.propSchema === "boolean") {
                styles[config.type] = true;
            }
            else {
                styles[config.type] = mark.attrs.stringValue;
            }
        }
        return styles;
    }
    /**
     * Adds styles to the currently selected content.
     * @param styles The styles to add.
     */
    addStyles(styles) {
        for (const [style, value] of Object.entries(styles)) {
            const config = this.schema.styleSchema[style];
            if (!config) {
                throw new Error(`style ${style} not found in styleSchema`);
            }
            if (config.propSchema === "boolean") {
                this._tiptapEditor.commands.setMark(style);
            }
            else if (config.propSchema === "string") {
                this._tiptapEditor.commands.setMark(style, { stringValue: value });
            }
            else {
                throw new UnreachableCaseError(config.propSchema);
            }
        }
    }
    /**
     * Removes styles from the currently selected content.
     * @param styles The styles to remove.
     */
    removeStyles(styles) {
        for (const style of Object.keys(styles)) {
            this._tiptapEditor.commands.unsetMark(style);
        }
    }
    /**
     * Toggles styles on the currently selected content.
     * @param styles The styles to toggle.
     */
    toggleStyles(styles) {
        for (const [style, value] of Object.entries(styles)) {
            const config = this.schema.styleSchema[style];
            if (!config) {
                throw new Error(`style ${style} not found in styleSchema`);
            }
            if (config.propSchema === "boolean") {
                this._tiptapEditor.commands.toggleMark(style);
            }
            else if (config.propSchema === "string") {
                this._tiptapEditor.commands.toggleMark(style, { stringValue: value });
            }
            else {
                throw new UnreachableCaseError(config.propSchema);
            }
        }
    }
    /**
     * Gets the currently selected text.
     */
    getSelectedText() {
        return this._tiptapEditor.state.doc.textBetween(this._tiptapEditor.state.selection.from, this._tiptapEditor.state.selection.to);
    }
    /**
     * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.
     */
    getSelectedLinkUrl() {
        return this._tiptapEditor.getAttributes("link").href;
    }
    /**
     * Creates a new link to replace the selected content.
     * @param url The link URL.
     * @param text The text to display the link with.
     */
    createLink(url, text) {
        if (url === "") {
            return;
        }
        const { from, to } = this._tiptapEditor.state.selection;
        if (!text) {
            text = this._tiptapEditor.state.doc.textBetween(from, to);
        }
        const mark = this.pmSchema.mark("link", { href: url });
        this.dispatch(this._tiptapEditor.state.tr
            .insertText(text, from, to)
            .addMark(from, from + text.length, mark));
    }
    /**
     * Checks if the block containing the text cursor can be nested.
     */
    canNestBlock() {
        return canNestBlock(this);
    }
    /**
     * Nests the block containing the text cursor into the block above it.
     */
    nestBlock() {
        nestBlock(this);
    }
    /**
     * Checks if the block containing the text cursor is nested.
     */
    canUnnestBlock() {
        return canUnnestBlock(this);
    }
    /**
     * Lifts the block containing the text cursor out of its parent.
     */
    unnestBlock() {
        unnestBlock(this);
    }
    /**
     * Moves the block containing the text cursor up. If the previous block has
     * children, moves it to the end of its children. If there is no previous
     * block, but the current block is nested, moves it out of & before its parent.
     */
    moveBlockUp() {
        moveBlockUp(this);
    }
    /**
     * Moves the block containing the text cursor down. If the next block has
     * children, moves it to the start of its children. If there is no next block,
     * but the current block is nested, moves it out of & after its parent.
     */
    moveBlockDown() {
        moveBlockDown(this);
    }
    /**
     * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list
     * items are un-nested in the output HTML.
     *
     * @param blocks An array of blocks that should be serialized into HTML.
     * @returns The blocks, serialized as an HTML string.
     */
    async blocksToHTMLLossy(blocks = this.document) {
        const exporter = createExternalHTMLExporter(this.pmSchema, this);
        return exporter.exportBlocks(blocks, {});
    }
    /**
     * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.
     *
     * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)
     * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)
     *
     * @param blocks An array of blocks that should be serialized into HTML.
     * @returns The blocks, serialized as an HTML string.
     */
    async blocksToFullHTML(blocks) {
        const exporter = createInternalHTMLSerializer(this.pmSchema, this);
        return exporter.serializeBlocks(blocks, {});
    }
    /**
     * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and
     * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote
     * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.
     * @param html The HTML string to parse blocks from.
     * @returns The blocks parsed from the HTML string.
     */
    async tryParseHTMLToBlocks(html) {
        return HTMLToBlocks(html, this.schema.blockSchema, this.schema.inlineContentSchema, this.schema.styleSchema, this.pmSchema);
    }
    /**
     * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of
     * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.
     * @param blocks An array of blocks that should be serialized into Markdown.
     * @returns The blocks, serialized as a Markdown string.
     */
    async blocksToMarkdownLossy(blocks = this.document) {
        return blocksToMarkdown(blocks, this.pmSchema, this, {});
    }
    /**
     * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on
     * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it
     * as text.
     * @param markdown The Markdown string to parse blocks from.
     * @returns The blocks parsed from the Markdown string.
     */
    async tryParseMarkdownToBlocks(markdown) {
        return markdownToBlocks(markdown, this.schema.blockSchema, this.schema.inlineContentSchema, this.schema.styleSchema, this.pmSchema);
    }
    /**
     * Updates the user info for the current user that's shown to other collaborators.
     */
    updateCollaborationUserInfo(user) {
        if (!this.options.collaboration) {
            throw new Error("Cannot update collaboration user info when collaboration is disabled.");
        }
        this._tiptapEditor.commands.updateUser(user);
    }
    /**
     * A callback function that runs whenever the editor's contents change.
     *
     * @param callback The callback to execute.
     * @returns A function to remove the callback.
     */
    onChange(callback) {
        if (this.headless) {
            // Note: would be nice if this is possible in headless mode as well
            return;
        }
        const cb = () => {
            callback(this);
        };
        this._tiptapEditor.on("update", cb);
        return () => {
            this._tiptapEditor.off("update", cb);
        };
    }
    /**
     * A callback function that runs whenever the text cursor position or selection changes.
     *
     * @param callback The callback to execute.
     * @returns A function to remove the callback.
     */
    onSelectionChange(callback) {
        if (this.headless) {
            return;
        }
        const cb = () => {
            callback(this);
        };
        this._tiptapEditor.on("selectionUpdate", cb);
        return () => {
            this._tiptapEditor.off("selectionUpdate", cb);
        };
    }
    openSuggestionMenu(triggerCharacter, pluginState) {
        const tr = this.prosemirrorView.state.tr;
        const transaction = pluginState && pluginState.deleteTriggerCharacter
            ? tr.insertText(triggerCharacter)
            : tr;
        this.prosemirrorView.focus();
        this.prosemirrorView.dispatch(transaction.scrollIntoView().setMeta(this.suggestionMenus.plugin, {
            triggerCharacter: triggerCharacter,
            deleteTriggerCharacter: pluginState?.deleteTriggerCharacter || false,
            ignoreQueryLength: pluginState?.ignoreQueryLength || false,
        }));
    }
}
//# sourceMappingURL=BlockNoteEditor.js.map