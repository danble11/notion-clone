import { NodeSelection, TextSelection } from "prosemirror-state";
import { CellSelection } from "prosemirror-tables";
import { getBlockInfoFromSelection } from "../../../getBlockInfoFromPos.js";
import { getNodeById } from "../../../nodeUtil.js";
// `getBlockSelectionData` and `updateBlockSelectionFromData` are used to save
// and restore the selection within a block, when the block is moved.
function getBlockSelectionData(editor) {
    const { bnBlock } = getBlockInfoFromSelection(editor._tiptapEditor.state);
    const selectionData = {
        blockId: bnBlock.node.attrs.id,
        blockPos: bnBlock.beforePos,
    };
    if (editor._tiptapEditor.state.selection instanceof CellSelection) {
        return {
            ...selectionData,
            type: "cell",
            anchorCell: editor._tiptapEditor.state.selection
                .$anchorCell.pos,
            headCell: editor._tiptapEditor.state.selection
                .$headCell.pos,
        };
    }
    else if (editor._tiptapEditor.state.selection instanceof NodeSelection) {
        return {
            ...selectionData,
            type: "node",
            from: editor._tiptapEditor.state.selection.from,
        };
    }
    else {
        return {
            ...selectionData,
            type: "text",
            anchor: editor._tiptapEditor.state.selection.anchor,
            head: editor._tiptapEditor.state.selection.head,
        };
    }
}
function updateBlockSelectionFromData(editor, data) {
    const blockPos = getNodeById(data.blockId, editor._tiptapEditor.state.doc).posBeforeNode;
    let selection;
    if (data.type === "cell") {
        selection = CellSelection.create(editor._tiptapEditor.state.doc, data.anchorCell + (blockPos - data.blockPos), data.headCell + (blockPos - data.blockPos));
    }
    else if (data.type === "node") {
        selection = NodeSelection.create(editor._tiptapEditor.state.doc, data.from + (blockPos - data.blockPos));
    }
    else {
        selection = TextSelection.create(editor._tiptapEditor.state.doc, data.anchor + (blockPos - data.blockPos), data.head + (blockPos - data.blockPos));
    }
    editor._tiptapEditor.view.dispatch(editor._tiptapEditor.state.tr.setSelection(selection));
}
export function moveSelectedBlockAndSelection(editor, referenceBlock, placement) {
    const { block } = editor.getTextCursorPosition();
    const selectionData = getBlockSelectionData(editor);
    editor.removeBlocks([block]);
    editor.insertBlocks([block], referenceBlock, placement);
    updateBlockSelectionFromData(editor, selectionData);
}
export function moveBlockUp(editor) {
    // This function currently only supports moving a single block.
    const editorSelection = editor.getSelection();
    if (editorSelection && editorSelection.blocks.length > 1) {
        return;
    }
    const { prevBlock, parentBlock } = editor.getTextCursorPosition();
    let referenceBlockId;
    let placement;
    if (!prevBlock) {
        if (parentBlock) {
            referenceBlockId = parentBlock.id;
            placement = "before";
        }
    }
    else if (prevBlock.children.length > 0) {
        referenceBlockId = prevBlock.children[prevBlock.children.length - 1].id;
        placement = "after";
    }
    else {
        referenceBlockId = prevBlock.id;
        placement = "before";
    }
    if (!referenceBlockId || !placement) {
        return;
    }
    moveSelectedBlockAndSelection(editor, referenceBlockId, placement);
}
export function moveBlockDown(editor) {
    // This function currently only supports moving a single block.
    const editorSelection = editor.getSelection();
    if (editorSelection && editorSelection.blocks.length > 1) {
        return;
    }
    const { nextBlock, parentBlock } = editor.getTextCursorPosition();
    let referenceBlockId;
    let placement;
    if (!nextBlock) {
        if (parentBlock) {
            referenceBlockId = parentBlock.id;
            placement = "after";
        }
    }
    else if (nextBlock.children.length > 0) {
        referenceBlockId = nextBlock.children[0].id;
        placement = "before";
    }
    else {
        referenceBlockId = nextBlock.id;
        placement = "after";
    }
    if (!referenceBlockId || !placement) {
        return;
    }
    moveSelectedBlockAndSelection(editor, referenceBlockId, placement);
}
//# sourceMappingURL=moveBlock.js.map