import { blockToNode } from "../../../nodeConversions/blockToNode.js";
import { nodeToBlock } from "../../../nodeConversions/nodeToBlock.js";
import { getNodeById } from "../../../nodeUtil.js";
export function insertBlocks(editor, blocksToInsert, referenceBlock, placement = "before") {
    const id = typeof referenceBlock === "string" ? referenceBlock : referenceBlock.id;
    const nodesToInsert = [];
    for (const blockSpec of blocksToInsert) {
        nodesToInsert.push(blockToNode(blockSpec, editor.pmSchema, editor.schema.styleSchema));
    }
    const { node, posBeforeNode } = getNodeById(id, editor._tiptapEditor.state.doc);
    // TODO: we might want to use the ReplaceStep directly here instead of insert,
    // because the fitting algorithm should not be necessary and might even cause unexpected behavior
    if (placement === "before") {
        editor.dispatch(editor._tiptapEditor.state.tr.insert(posBeforeNode, nodesToInsert));
    }
    if (placement === "after") {
        editor.dispatch(editor._tiptapEditor.state.tr.insert(posBeforeNode + node.nodeSize, nodesToInsert));
    }
    // Now that the `PartialBlock`s have been converted to nodes, we can
    // re-convert them into full `Block`s.
    const insertedBlocks = [];
    for (const node of nodesToInsert) {
        insertedBlocks.push(nodeToBlock(node, editor.schema.blockSchema, editor.schema.inlineContentSchema, editor.schema.styleSchema, editor.blockCache));
    }
    return insertedBlocks;
}
//# sourceMappingURL=insertBlocks.js.map